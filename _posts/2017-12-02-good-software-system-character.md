---
layout: post
title: "Introduction: What Does A Good Software System Looks Like"
keywords: ["technical-thinking"]
description: "What Does A Good Software System Looks Like"
category: "technical-thinking"
tags: ["technical-thinking"]
---
{% include JB/setup %}


# 介绍

本文旨在讨论 一个宽泛的问题 好的软件项目 有哪些共通的特点/特性。试图从内外（使用者，开发者，技术学习)不同的角度来总结 真正好的软件项目会长成什么样子。

**本文只是开篇介绍** 具体每个章节的详解在后续文章会陆续娓娓道来。

简单而言 就是在软件系统发展 演进的生命周期中 对所有的利益相关者（stakeholder）都要友好，产生正向反馈。

* 备孕阶段

首先 **用户**会提出需求【某些技术或者中间件的项目 技术人员可能会主动定义需求】, 然后**产品经理**会收集、汇总、提炼项目需求, **架构师**定义技术需求，开始做软件设计和构架 并和依赖上下游 用户 开发团队一起讨论 审核 达成一致 并和**软件团队**负责 报价 预见风险 评估实施的可能性。

* 孕育阶段

**开发团队**负责 定义本阶段需要开发的功能 搭建系统框架 逐步执行把系统变成现实。 

* 出生阶段

**开发团队**负责线上系统发布 确认系统状态和用户体验影响，及时通知用户和运维团队发布状态。
**运维团队**负责线上常规支持(容灾异常处理和恢复)，评估线上服务故障等级来决定引入**开发团队**哪种程度的支持。

* 成长发展阶段

在持续客户支持 和 客户深度使用的过程中，逐步收集 提炼新需求 并能评估紧急程度和优先级。在重复以上三阶段 使系统持续演进发展。 

```
各个阶段间有时候 并不是完全泾渭分明，会有来回的迭代，比如每次有新功能开发完成（孕育阶段），都需要发布 （出生阶段），有新的用户需求就需要进一步收集 讨论 提炼成技术需求（成长发展阶段）。

另外，想要把一件事情做好 最终就要理顺生产关系 升级产生力  优化生产方式。下面提到友好性的部分 也简单归类哪些是和生产力 生产关系 生产方式相关的。
```

# 友好性

![Good System Outline]({{ site.JB.IMAGE_PATH }}/good_system_outline.png "Good System Outline")


## 理解问题集
理解问题集（到底要解决什么问题 什么问题不在范畴内），这是一切讨论的起源 而且需要和目标客户达成一致 解决客户真正的问题 而不是想象出来的"假"问题。为了解决不存在的问题而炫(耀)技(术)，都是徒劳不负责任的的表现。
对于单个软件系统（不指软件生态或者产品线）而言，有时候 知其不可为更为重要 与其堆砌功能做个大而全 但每块功能模块都不够精深 足够的好 还不如专注 把核心问题集较好地解决。用较少的投入来实现最大化ROI。Do less Do Great。
参看附录#1（单一责任原则），2（基于unix风格的分布式数据处理）
* notes：这里的工程团队是个宽泛的概念 涵盖 开发人员 构架师 产品经理和开发经理。 

## 客户/用户友好
终极目标是对客户需求 (包括问答 支持 新功能请求) 快速响应，同时为了最大化用户体验提升 要投入最多的精力在用户的核心需求和问题上。对于紧急但不重要的需求 和 重要不紧急的需求 需要有一定的平衡和取舍。
更进一步的要求是 尽可能降低用户使用的学习曲线 提升用户体验。

## 友好的工程实践
工程实践(生产方式)的优化和提升 直接决定整体生产力和实际产出。因而 如何构架友好的工程实践非常重要。
生产方式包括 整体技术构架[具体参看附录#3: 每个架构师都应该研究下康威定律]、编程语言选择、技术选型、技术栈、依赖框架、算法、数据结构、上下游服务间通信协议。由此 对于每个工程师本身提出了很高技术要求 [具体参看附录#5: 程序员技术练级攻略]。

## 工程团队友好
工程团队作为生产力的主体，能提供优良的环境以帮助他们更好地产出 显得尤为重要。其中包括：
* 如何关联软件系统和工程师个人职业生涯发展的关系 进一步激励团队
* 如何构建 良性持续改进的工作沟通方式 帮助和成就团队每个成员的成功 优秀地完成工作
* 团队会有流动，会有新人加入 老人离去 如何保持人才密度 保持整体工程实践的一致性 保持设计整体延续性都是重要课题。

## 运维友好
软件系统发布过程中 和 上线之后 都需要运维持续的维护，尤其是在软硬件故障发生的过程中 快速响应 定位问题 评估和控制错误等级和范围 快速修复 以最大程度降低客户影响，这些都是运维团队的重要KPI。
但 这个KPI不只是针对运维团队本身的 在软件系统设计之初 就需要好好思考 系统上线之后对线上的影响
* Design for failure 在早期软件设计时就需要被考虑到 参看[附录6：AWS_Cloud_Best_Practices#Cloud Best Practice-- Design for failure and nothing will fail]
* Design for scalability 有幸你的系统越来越热门，更多的用户来使用， 那么能动态水平扩容就是无缝地服务更多用户的必要条件。

## 项目管理友好
根据用户需求的总结，对于每个功能 客户支持 都需要有优先级、报价以及阶段性规划，这样才能心中有谱 知道每个阶段都需要完成的任务、代价有多大、需要哪些团队配合 有的放矢。

## 机器硬件友好
广义来说，好的软件系统可以用更少的硬件或资源就能达成一定良好的用户体验 用低廉的硬件就能完成关键的用户功能。这也是顺应当前微服务和云计算的潮流 我们再也不能靠高昂的硬件（mainframe或者纯物理机）来达成高性能 高吞吐量的服务质量，而是更多的多核虚拟机/Docker 实例来服务线上。
如何压榨单核 和内存 磁盘资源来实现更好的性能 就是所有技术人员都要好好思考的问题了。
而且 很多公有云都是按CPU core和服务时间来计费，这就直接关联整体运营成本。

# 强调

* 创项目（生孩子）难 持续维护演进项目（养孩子）更难 不要轻易退役任何一个在线使用的项目（淘汰每个孩子） 。对线上的项目 要有足够的敬畏之心和尊重。每个新项目（新生儿）都要定义其核心最小的问题集 不忘初心 【每次演进的时候 都要记得 当初创项目的动机 是不是和该动机有一定的关联性】。

* 要有侧重 按优先级来逐步实现 不求尽善尽美 但求每次努力之后利益最大化。要尽量平衡追求技术完美的程度，  一切都要以满足和支持大多数用户大多数需求为主 同时 要有限度地预见用户未来可能的需求 来持续演进软件系统


# 附录
1. [单一责任原则](https://en.wikipedia.org/wiki/Single_responsibility_principle)
2. [基于unix风格的分布式数据处理](https://www.confluent.io/blog/apache-kafka-samza-and-the-unix-philosophy-of-distributed-data/)
3. [康威定律](http://www.infoq.com/cn/articles/every-architect-should-study-conway-law)
4. [江南白衣的Java性能优化指南](http://calvin1978.blogcn.com/articles/javatuning.html)
5. [程序员技术练级攻略](https://coolshell.cn/articles/4990.html)
6. [AWS_Cloud_Best_Practices](https://media.amazonwebservices.com/AWS_Cloud_Best_Practices.pdf)